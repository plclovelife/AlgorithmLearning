##### 一、冒泡排序
基本思想：比较相邻的两个数据，如果前面数据大于后面的数据，就将两个数据交换。
设数组长度为N。<br>
1．这样对数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1个位置。<br>
2．N=N-1，如果N不为0就重复前面二步，否则排序完成。<br>
> 代码实现（C++）
```
void Swap(int &a, int &b)//交换元素位置
{
    int c = a;
    a = b;
    b = c;
}
void PrinfArray(int a[],int n)//输出数组
{
    for (int i = 0; i < n; i++)
    {
	printf("%d", a[i]);
	putchar('\n');
    }

}
void BubbleSort1(int a[], int n)//基本冒泡排序
{
    int i, j;
    for (i = 0; i < n; i++)
    {
	for (j = 1; j < n-i; j++)
	{
	    if (a[j - 1] > a[j])
	    {
		Swap(a[j - 1], a[j]);
	    }
	}
     }
}
void BubbleSort2(int a[], int n)//优化的冒泡排序
{
    int j, k;
    k = n;
    bool flag = true;//设置一个标志

    while (flag)//如果这一趟发生了交换，则为true，否则为false。
    {	//明显如果有一趟没有发生交换，说明排序已经完成。
	flag = false;
	for (j = 1; j < k; j++)
	{
	    if (a[j - 1] > a[j])
	    {
		Swap(a[j - 1], a[j]);
		flag = true;
	    }
	}
	k--;
    }
}
int main()
{
    const int N = 10;//长度为10
    int a[N] = { 6,763,87,2,4,7,98,5,0,14 };//默认数组
    //BubbleSort1(a, N);
    //BubbleSort2(a, N);
    PrinfArray(a, N);
    return 0;
}
```
> 运行结果
 
 原数组a[]={6,763,87,2,4,7,98,5,0,14}<br>
 输出结果：
![result](https://github.com/plclovelife/studyalgorithm/blob/master/Image/Bubble.png?raw=true)


